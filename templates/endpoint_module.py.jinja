from typing import Any, Dict, List, Optional, Union, cast

import httpx


from ... import cli

from ...client.client import AuthenticatedClient, Client
from ...client.types import Response, UNSET, Unset

from ...client.api.{{ endpoint.tag }}.{{ python_identifier(endpoint.name) }} import sync_detailed

{% for relative in endpoint.relative_imports %}
{{ relative.replace('...', '...client.') }}
{% endfor %}

{% if endpoint.json_body %}
{% for relative in endpoint.json_body.relative_imports %}
{{ relative.replace('..', '...client.') }}
{% endfor %}
{% endif %}

{% from "endpoint_macros.py.jinja" import header_params, cookie_params, query_params, json_body, multipart_body,
    arguments, client, kwargs, parse_response, docstring %}

{% set return_string = endpoint.response_type() %}
{% set parsed_responses = (endpoint.responses | length > 0) and return_string != "Any" %}
{% set list_response = [] %}
{% for response_type in endpoint.responses if response_type.status_code == 200 %}
{# First check if response contains a list property; and store it in list_response for later #}
{% for prop in response_type.prop.required_properties if prop.name not in ('meta', 'links') and prop.get_instance_type_string() == 'list' and prop.inner_property.required_properties %}
{# This is required because of jinja 'for' variable scope #}
{% set _ = list_response.append(prop) %}
{% endfor %}
{# Second check if there are any non-list values, which means this isnt a list response #}
{% for prop in response_type.prop.required_properties if prop.name not in ('meta', 'links') and prop.get_instance_type_string() != 'list' %}
{# This is required because of jinja 'for' variable scope #}
{% set _ = list_response.clear() %}
{% endfor %}
{% endfor %}

{% if list_response %}
{% set list_response = list_response[0].inner_property %}
from ...runners import ListRunner
class Command(ListRunner):

    @property
    def default_format(self) -> List[str]:
        return [
            {% for prop in list_response.required_properties if not prop.required_properties and prop.get_instance_type_string() != 'list' %}
            '{{ prop.name }}',
            {% endfor %}
        ]

    @property
    def fields(self) -> Dict[str, str]:
        return {
            {% for prop in list_response.required_properties %}
            '{{ prop.name }}': """{{ prop.description }}""",
            {% endfor %}
            {% for prop in list_response.optional_properties %}
            '{{ prop.name }}': """{{ prop.description }}""",
            {% endfor %}
        }
{% else %}
from ...runners import CommandRunner
class Command(CommandRunner):
{% endif %}

    @property
    def name(self):
        return '{{ endpoint.name }}'

    @property
    def description(self):
        return """{{ endpoint.summary }}"""

    def configure(self, parser):
        """Add arguments for {{ endpoint.name }}"""
        {% for parameter in endpoint.path_parameters.values() %}
        parser.cli_argument('{{ parameter.name }}',
            {% if parameter.description %}description="""{{ parameter.description }}""", {% endif %}
            )
        {% endfor %}

        {% if endpoint.json_body %}
        {% if endpoint.json_body.class_info %}
        from ...client.models.{{ endpoint.json_body.class_info.module_name }} import {{ endpoint.json_body.class_info.name }}
        {% endif %}

        {%  if endpoint.json_body.get_instance_type_string() == 'list' %}
        {% set property = endpoint.json_body.inner_property %}
        parser.cli_argument('{{ key }}',
                nargs='*',
                {% if endpoint.json_body.description %}description="""{{ endpoint.json_body.description  }}""",{% endif %}
                )

        {% elif endpoint.json_body.class_info %}
        {% for property in endpoint.json_body.required_properties + endpoint.json_body.optional_properties %}

        parser.cli_argument('--{{  property.name.replace('_','-') }}',
                dest='{{  property.python_name }}',
                type={{ property.get_type_string() }},
                required={{ property.required }},
                description="""{{  property.description }}""",
                {%  if property.get_instance_type_string() == 'bool' %}
                action=cli.BooleanOptionalAction,
                {%  endif %}
                )
        {% endfor %}
        {% else %}
        # Unknown {{ endpoint.json_body.get_instance_type_string() }} {{ endpoint.json_body.template }}
        {% endif %}
        {% endif %}

        {% if endpoint.query_parameters %}
        {% for property in endpoint.query_parameters.values() if property.name not in ('page', 'per_page') %}
        parser.cli_argument('--{{  property.name.replace('_','-') }}',
                dest='{{  property.python_name }}',
                type={{ property.get_type_string() }},
                required=False,
                description="""{{  property.description }}""",
                )
        {% endfor %}
        {% endif %}


    def request(self,
        {% for parameter in endpoint.path_parameters.values() %}
        {{ parameter.to_string() }},
        {% endfor %}

        {% if endpoint.requires_security %}
        client: AuthenticatedClient,
        {% else %}
        client: Client,
        {% endif %}

        {% if endpoint.json_body %}
        {% if endpoint.json_body.get_instance_type_string() == 'list' %}
        {{ endpoint.tag }}: {{ endpoint.json_body.get_type_string() }}
        {% elif endpoint.json_body.class_info %}
        {% for property in endpoint.json_body.required_properties + endpoint.json_body.optional_properties %}
        {{ property.to_string() }},
        {% endfor %}
        {% endif %}
        {% endif %}

        {% set paginated=False %}
        {% if endpoint.query_parameters %}
        {% set paginated='page' in endpoint.query_parameters.keys() and 'per_page' in endpoint.query_parameters.keys() %}
        {% for property in endpoint.query_parameters.values() if property.name not in ('page', 'per_page') %}
        {{ property.to_string() }},
        {% endfor %}
        {% endif %}
        ) -> {{ endpoint.response_type() }}:

            {% if paginated %}
            page = 0
            per_page = 25
            has_next = True
            {% for response_type in endpoint.responses if response_type.status_code == 200 %}
            response: {{ response_type.prop.class_info.name }} = None
            {% endfor %}

            while has_next:
                page += 1
                page_response = sync_detailed(
            {% else %}
            return sync_detailed(
            {% endif %}
                {% for parameter in endpoint.path_parameters.values() %}
                {{ parameter.python_name }} = {{ parameter.python_name }},
                {% endfor %}
                client = client,

                {% if endpoint.json_body %}
                {% if endpoint.json_body.get_instance_type_string() == 'list' %}
                json_body = {{ endpoint.tag }},

                {% elif endpoint.json_body.class_info %}
                json_body = {{ endpoint.json_body.class_info.name }}(
                    {% for property in endpoint.json_body.required_properties + endpoint.json_body.optional_properties %}
                    {{ property.python_name }} = {{ property.python_name }},
                    {% endfor %}
                ),
                {% endif %}
                {% endif %}

                {% if endpoint.query_parameters %}
                {% for property in endpoint.query_parameters.values() if property.name not in ('page', 'per_page') %}
                    {{ property.python_name }} = {{ property.python_name }},
                {% endfor %}
                {% endif %}
            {% if not paginated %}
            ).parsed
            {% else %}
                page = page,
                per_page = per_page,
                )

                if page_response.status_code != 200:
                    return page_response.parsed

                has_next = page_response.parsed.links and page_response.parsed.links.pages.next_
                if not response:
                    response = page_response.parsed
                else:
                {% for response_type in endpoint.responses if response_type.status_code == 200 %}
                {% for prop in response_type.prop.required_properties if prop.name not in ('meta') %}
                {% if prop.get_instance_type_string() == 'list' %}
                    response.{{ prop.python_name }} += page_response.parsed.{{ prop.python_name }}
                {% else %}
                    {{ fail('unsupported', prop.prop.get_instance_type_string()) }}
                {% endif %}
                {% endfor %}
                {% endfor %}

            return response
            {% endif %}
